<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>RESTful Resource Naming</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Naming Tutorial: RESTful services are resource-based. How do you create those noun-based resource names? Here's how...">
    <meta name="author" content="Andrey Kumanyaev, Kaize Team">
    <!-- Le styles -->
    <link href="https://d7im4lln3lvbg.cloudfront.net/bootstrap/2.0.1/css/bootstrap.min.css" rel="stylesheet">
    <style type="text/css">
      body {
        padding-top: 60px;
        padding-bottom: 40px;
      }
    </style>
    <link href="https://d7im4lln3lvbg.cloudfront.net/bootstrap/2.0.1/css/bootstrap-responsive.min.css" rel="stylesheet">
    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
    <script src="//html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="container">
      <div class="row">
        <div class="span8">
          <h1>Resource Naming</h1>
        </div>
        <div class="span4">
          <ul class="pager">
            <li>
              <a href="httpmethods.html"><i class="icon-step-backward"></i> HTTP Methods</a>
            </li>
            <li>
              <a href="idempotency.html">Idempotence <i class="icon-step-forward"></i></a>
            </li>
          </ul>
        </div>
      </div>
      <div class="row">
        <div class="span12">
          <p>
            Кроме правильного использования HTTP глаголов, именование ресурсов, вероятно, самая
            обсуждаемая и важная концепция для понимания во время создания понятной и легкоиспользуемого
            API для Web-сервиса. Когда ресурсы названы хорошо, API интуитивен и легок в использовании.
            Если же ресурсы названы плохо, тот же самый API может показаться неуклюжим и трудным
            в понимании и использовании. Ниже приведены несколько подсказок, как продолжить создавать
            URI ресурсов для нового API.
          </p>
          <p>
            Фактически RESTful API - это всего лишь набор URI, HTTP вызовов к этим URI и некоторое
            количество представлений ресурсов в формате JSON и/или XML, многие из которых будут
            содержать перекрестные ссылки.
            <!-- FIXME --> The RESTful principal of addressability is covered by the URIs.
            У каждого ресурса есть свой адрес или URI: вся интересная информация, которую
            сервер может предоставить, представлена как ресурс. Ограничение однообразия интерфейса
            частично реализовано с помощью комбинаций URI и HTTP глаголов и их использованием в
            соответствии со стандартами и конвенциями.
          </p>
          <p>
            Когда вы решаете, какие ресурсы буду в вашей системе, называйте их существительными,
            в противоположность глаголам, или действиям. Другими словами, URI должен ссылаться
            на ресурс, а не на действие. Еще один отличающий фактор - у существительных есть такие
            свойства, которых нет у глаголов.
          </p>
          <p>Ниже приведены примеры ресурсов:</p>
          <ul>
            <li>Пользователи системы.</li>
            <li>Курсы, в которых зарегистрирован студент.</li>
            <li>История сообщений пользователя.</li>
            <li>Пользователь, который подписан на другого пользователя.</li>
            <li>Пользователи, которые подписаны на другого пользователя.</li>
            <li>Статья о верховой езде.</li>
          </ul>
          <p>
            Каждый ресурс сервиса должен иметь хотя бы один URI, идентифицирующий его. И лучше всего,
            когда этот URI имеет смысл и адекватно описывает этот ресурс. URI должны иметь
            предсказуемую, иерархичную структуру, чтобы увеличить понятность и, как следствие,
            юзабилити: предсказуемость означает, что они консистентны, иерархичность означает, что
            у данных есть структура взаомоотношений. Это не принцип и не ограничение REST, но это
            улучшает API.
          </p>
          <p>
            RESTful API пишут для потребителей. Назавания и струтрука URI должна передавать
            смысл этим потребителям. Очень часто трудно понять, где дожлны быть границы, но с пониманием
            ваших данных вы поймете и то, что имеет смысл возвращать как представление вашим клиентам.
            Проектируйте для клиентов, а не для ваших данных.
          </p>
          <p>
            Давайте предположим, что мы описываем систему с покупателями, заказами, отдельными
            позициями, продуктами и т. д. Рассмотрим URI, включенные в описание ресурсов этого
            сервиса:
          </p>
        </div>
      </div>
      <div class="row">
        <div class="span12">
          <ul class="nav nav-tabs">
            <li class="active"><a href="#examples" data-toggle="tab">Resource URI Examples</a></li>
            <li><a href="#antipatterns" data-toggle="tab">Resource Naming Anti-Patterns</a></li>
            <li><a href="#pluralization" data-toggle="tab">Pluralization</a></li>
          </ul>
          <div id="namingTabContent" class="tab-content">
            <div class="tab-pane fade in active" id="examples">
              <p>Чтобы создать нового покупателя в системе мы используем:<br/>
              <em>POST http://www.example.com/customers</em></p>
              <p>Чтобы получить информацию о покупателе с ID# 33245:<br/>
              <em>GET http://www.example.com/customers/33245</em>
              Тот же URI мы используем для PUT и DELETE, чтобы обновлять и удалять, соответственно.</p>
              <p>Ниже предложены URI для продуктов:<br/>
              <em>POST http://www.example.com/products</em>
              для создания нового продукта.</p>
              <p><em>GET|PUT|DELETE http://www.example.com/products/66432</em><br/>
              для чтения, обновления, удаления продукта с ID# 66432, соответственно.</p>
              <p>
                Теперь становится весело... Как насчет создания нового заказа у покупателя? Один
                вариант - POST http://www.example.com/orders. Это может работать для создания
                заказа, но здесь, пожалуй, не учитывается покупатель.
              </p>
              <p>Поскольку мы хотим создать заказ для покупателя, (заметьте связь), этот URI, очевидно,
              не так интуитивен, как мог бы быть. Очевидно, что следующий URI предлагает большую
              ясность: <em>POST http://www.example.com/customers/33245/orders</em> Теперь мы знаем,
              что создаем заказ для покупателя с ID# 33245.</p>
              <p>Что же венет следующее?<br/>
              <em>GET http://www.example.com/customers/33245/orders</em><br/>
              Вероятно, список заказов покупателя #33245. Заметьте: мы можем не поддерживать DELETE
              или PUT для этого URL, поскольку он оперирует коллекцией.
              </p>
              <p>Теперь, продолжая концепцию иерархичности, как насчет следующего URI?<br/>
              <em>POST http://www.example.com/customers/33245/orders/8769/lineitems</em><br/>
              Это может добавлять отдельную позицию в заказ #8769 (который принадлежить покупателю
              #33245). Точно! GET на этот URI вернет все отдельные позиции данного заказа. Как бы
              то ни было, если отдельные позиции нельзя рассматривать только в контексте
              покупателя, или из можно рассматривать вне его контекста, мы можем предложить
              POST www.example.com/orders/8769/lineitems.</p>
              <p>Наряду с этими строками, поскольку может быть несколько URI для заданного
                ресурса, мы также можем предложить GET http://www.example.com/orders/8769, который
                возвращает информацию о заказе по его ID без указания ID покупателя
              </p>
              <p>Спускаясь глубже по иерархии:<br/>
              <em>GET http://www.example.com/customers/33245/orders/8769/lineitems/1</em><br/>
              Может возвращать только первую отдельную позицию в заказе.
              </p>
              <p>
                К этому моменту вы уже можете видеть, как работает концепция иерархичности. Нет никаких
                жестких правил, убедитесь только, что предложенная структура понятна потребителю
                ваших сервисов. Как и все в ремесле разработки ПО, именование критично для успеха.
              </p>
              <p>
                Взгляните на некоторые широко используемые API, чтобы приобрести навык проектирования
                и используйте интуицию своих коллег, чтобы улучшить URI ресурсов вашего API. Ниже
                приведены некоторые примеры API:
              </p>
              <ul>
                <li>Twitter: https://dev.twitter.com/docs/api</li>
                <li>Facebook: http://developers.facebook.com/docs/reference/api/</li>
                <li>LinkedIn: https://developer.linkedin.com/apis</li>
              </ul>
            </div>

            <div class="tab-pane fade" id="antipatterns">
              <p>While we've discussed some examples of appropriate resource names, sometimes it's informative to see some anti-patterns. Below are some examples of poor RESTful resource URIs seen in the &quot;wild.&quot; These are examples of what not to do!</p>
              <p>First up, often services use a single URI to specify the service interface, using query-string parameters to specify the requested operation and/or HTTP verb. For example to update customer with ID 12345, the request for a JSON body might be:</p>
              <p><em>GET http://api.example.com/services?op=update_customer&id=12345&format=json</em></p>
              <p>By now, you're above doing this. Even though the 'services' URL node is a noun, this URL is not self- descriptive as the URI hierarchy is the same for all requests. Plus, it uses GET as the HTTP verb even though we're performing an update. This is counter-intuitive and is painful (even dangerous) to use as a client.</p>
              <p>Here's another example following the same operation of updating a customer:</p>
              <p><em>GET http://api.example.com/update_customer/12345</em></p>
              <p>And its evil twin:</p>
              <p><em>GET http://api.example.com/customers/12345/update</em></p>
              <p>You'll see this one a lot as you visit other developer's service suites. Note that the developer is attempting to create RESTful resource names and has made some progress. But you're better than this —able to identify the verb phrase in the URL. Notice that we don't need to use the 'update' verb phrase in the URL because we can rely on the HTTP verb to inform that operation. Just to clarify, the following resource URL is redundant:</p>
              <p><em>PUT http://api.example.com/customers/12345/update</em></p>
              <p>With both PUT and 'update' in the request, we're offering to confuse our service consumers! Is 'update' the resource? So, we've spent some time beating the horse at this point. I'm certain you understand...</p>
            </div>
            <div class="tab-pane fade" id="pluralization">
              <p>Let's talk about the debate between the pluralizers and the &quot;singularizers&quot;... Haven't heard of that debate? It does exist. Essentially, it boils down to this question...</p>
              <p>Should URI nodes in your hierarchy be named using singular or plural nouns? For example, should your URI for retrieving a representation of a customer resource look like this:</p>
              <p><em>GET http://www.example.com/customer/33245</em> or:
              <em>GET http://www.example.com/customers/33245</em></p>
              <p>There are good arguments on both sides, but the commonly-accepted practice is to always use plurals in node names to keep your API URIs consistent across all HTTP methods. The reasoning is based on the concept that customers are a collection within the service suite and the ID (e.g. 33245) refers to one of those customers in the collection.</p>
              <p>Using this rule, an example multi-node URI using pluralization would look like (emphasis added):</p>
              <p><em>GET http://www.example.com/<strong>customers</strong>/33245/<strong>orders</strong>/8769/<strong>lineitems</strong>/1</em></p>
              <p>with 'customers', 'orders', and 'lineitems' URI nodes all being their plural forms.</p>
              <p>This implies that you only really need two base URLs for each root resource. One for creation of the resource within a collection and the second for reading, updating and deleting the resource by its identifier. For example the creation case, using customers as the example, is handled by the following URL:</p>
              <p><em>POST http://www.example.com/customers</em></p>
              <p>And the read, update and delete cases are handled by the following:</p>
              <p><em>GET|PUT|DELETE http://www.example.com/customers/{id}</em></p>
              <p>As mentioned earlier, there may be multiple URIs for a given resource, but as a minimum full CRUD capabilities are aptly handled with two simple URIs.</p>
              <p>You ask if there is a case where pluralization doesn't make sense. Well, yes, in fact there is. When there isn't a collection concept in play. In other words, it's acceptable to use a singularized resource name when there can only be one of the resource—it's a singleton resource. For example, if there was a single, overarching configuration resource, you might use a singularized noun to represent that:</p>
              <p><em>GET|PUT|DELETE http://www.example.com/configuration</em></p>
              <p>Note the lack of a configuration ID and usage of POST verb. And say that there was only one configuration per customer, then the URL might be:</p>
              <p><em>GET|PUT|DELETE http://www.example.com/customers/12345/configuration</em></p>
              <p>Again, no ID for the configuration and no POST verb usage. Although, I'm sure that in both of these cases POST usage might be argued to be valid. Well... OK.</p>
            </div>
          </div>
        </div>
      </div>
      <hr>
      <footer>
        <p>
          &copy;Pearson eCollege, 2012. All rights reserved.
        </p>
      </footer>
    </div> <!-- /container -->
    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </a>
          <a class="brand" href="http://www.restapitutorial.ru">Руководство по REST API</a>
          <div class="nav-collapse">
            <ul class="nav">
              <li class="active"><a href="/">Главная</a></li>
              <li class="dropdown" id="api-school"><a class="dropdown-toggle" data-toggle="dropdown" href="#">Руководства<b class="caret"></b></a>
                <ul class="dropdown-menu">
                  <li><a href="/lessons/whatisrest.html">Что такое REST?</a></li>
                  <li><a href="/lessons/restquicktips.html">REST Quick Tips</a></li>
                  <li><a href="/lessons/httpmethods.html">HTTP методы</a></li>
                  <li><a href="/lessons/restfulresourcenaming.html">Именование ресурсов</a></li>
                  <li><a href="/lessons/idempotency.html">Идемпотентность</a></li>
                </ul>
              </li>
              <li><a href="/httpstatuscodes.html">HTTP коды ответа</a></li>
              <li><a href="/resources.html">Источники и ресурсы</a></li>
            </ul>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
    <script src="https://d7im4lln3lvbg.cloudfront.net/bootstrap/2.0.1/js/bootstrap.min.js"></script>
    <a href="https://github.com/zzet/RestApiTutorial.ru"><img style="position: absolute; top: 0; right: 0; border: 0; z-index: 1050;" src="https://a248.e.akamai.net/camo.github.com/e6bef7a091f5f3138b8cd40bc3e114258dd68ddf/687474703a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f7265645f6161303030302e706e67" alt="Fork me on GitHub"></a>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
          (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
          })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

          ga('create', 'UA-46669941-1', 'restapitutorial.ru');
          ga('require', 'linkid', 'linkid.js');
          ga('send', 'pageview');

    </script>
  </body>
</html>
